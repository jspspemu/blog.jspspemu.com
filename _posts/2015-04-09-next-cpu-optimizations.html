---
layout: post
title: Next cpu optimizations
date: '2015-04-09T19:34:00.002+02:00'
author: Carlos Ballesteros Velasco
tags:
- tech info
modified_time: '2015-04-09T19:34:56.982+02:00'
blogger_id: tag:blogger.com,1999:blog-5631155793606690437.post-6017439572160936549
blogger_orig_url: http://blog.jspspemu.com/2015/04/next-cpu-optimizations.html
---

I have resumed the work of the emulator. Now I plan to make some optimizations to be able to reach a good speed in mobile.<br /><br />Now most generated functions are like this:<br /><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">function state(state) {</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><span class="Apple-tab-span" style="white-space: pre;"> </span>var expectedRA = state.getRA();</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><span class="Apple-tab-span" style="white-space: pre;"> </span>/*08804338*/ /* &nbsp; &nbsp;lui */ &nbsp;state.gpr[8] = 0x08820000;</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><span class="Apple-tab-span" style="white-space: pre;"> </span>/*0880433c*/ /* &nbsp; addu */ &nbsp;state.gpr[6] = (0 + 0);</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><span class="Apple-tab-span" style="white-space: pre;"> </span>/*08804340*/ /* &nbsp; addu */ &nbsp;state.gpr[3] = (0 + 0);</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><span class="Apple-tab-span" style="white-space: pre;"> </span>/*08804344*/ /* &nbsp;addiu */ &nbsp;state.gpr[8] = (state.gpr[8] + -20752);</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><span class="Apple-tab-span" style="white-space: pre;"> </span>/*08804348*/ /* &nbsp;addiu */ &nbsp;state.gpr[7] = (0 + 5);</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><span class="Apple-tab-span" style="white-space: pre;"> </span>/*0880434c*/ /* &nbsp; addu */ &nbsp;state.gpr[4] = (state.gpr[8] + 0);</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><span class="Apple-tab-span" style="white-space: pre;"> </span>/*08804350*/ /* &nbsp; &nbsp;lui */ &nbsp;state.gpr[2] = 0x00500000;</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><span class="Apple-tab-span" style="white-space: pre;"> </span>while (true) {</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><span class="Apple-tab-span" style="white-space: pre;">  </span>/*08804354*/ /* &nbsp; &nbsp; lh */ &nbsp;state.gpr[5] = state.lh(((state.gpr[4] + 0) | 0));</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><span class="Apple-tab-span" style="white-space: pre;">  </span>/*08804358*/ /* &nbsp;addiu */ &nbsp;state.gpr[2] = (state.gpr[2] + -1);</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><span class="Apple-tab-span" style="white-space: pre;">  </span>/*0880435c*/ /* &nbsp;addiu */ &nbsp;state.gpr[4] = (state.gpr[4] + 2);</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><span class="Apple-tab-span" style="white-space: pre;">  </span>/*08804360*/ /* &nbsp; &nbsp;bne */ &nbsp;state.BRANCHFLAG = (state.gpr[2] != 0);</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><span class="Apple-tab-span" style="white-space: pre;">  </span>state.BRANCHPC = 0x08804354;</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><span class="Apple-tab-span" style="white-space: pre;">  </span>/*08804364*/ /* &nbsp; addu */ &nbsp;state.gpr[3] = (state.gpr[3] + state.gpr[5]);</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><span class="Apple-tab-span" style="white-space: pre;">  </span>if (state.BRANCHFLAG) { state.PC = state.BRANCHPC; } else { state.PC = 0x08804368; }</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><span class="Apple-tab-span" style="white-space: pre;">  </span>if (!state.BRANCHFLAG) return;</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><span class="Apple-tab-span" style="white-space: pre;"> </span>}</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><span class="Apple-tab-span" style="white-space: pre;"> </span>return;</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">}</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span>Just a single loop, using the gpr Int32Array directly, and giving up soon. No calling or jumping other functions either. So it is slow. Faster than a pure interpreter, but much slower than a proper dynarec.<br /><br />How to optimize this?<br /><br /><a name='more'></a><br /><h2>Local variable allocation:</h2><span style="font-family: Courier New, Courier, monospace;">while (state.gpr[5] &lt; 10) {</span><br /><span style="font-family: Courier New, Courier, monospace;">&nbsp; &nbsp; state.gpr[5] =&nbsp;<span style="font-size: x-small;">state.lh(((state.gpr[4] + 0) | 0));</span></span><br /><span style="font-family: Courier New, Courier, monospace;">&nbsp; &nbsp; state.gpr[5] = state.gpr[5]&nbsp;+ 1;</span><br /><span style="font-family: Courier New, Courier, monospace;">}</span><br /><br />This is the same as:<br /><br /><span style="font-family: Courier New, Courier, monospace;">var gpr5 = state.gpr[5];</span><br /><span style="font-family: Courier New, Courier, monospace;">var gpr4 = state.gpr[4];</span><br /><span style="font-family: Courier New, Courier, monospace;">while (gpr5&nbsp;&lt; 10) {</span><br /><span style="font-family: Courier New, Courier, monospace;">&nbsp; &nbsp;&nbsp;gpr5&nbsp;=&nbsp;<span style="font-size: x-small;">state.lh(((gpr4 + 0) | 0));</span></span><br /><span style="font-family: Courier New, Courier, monospace;">&nbsp; &nbsp;&nbsp;gpr5&nbsp;= (gpr5&nbsp;+ 1) | 0;</span><br /><span style="font-family: Courier New, Courier, monospace;">}</span><br /><span style="font-family: Courier New, Courier, monospace;">state.gpr[4] = gpr4;</span><br /><span style="font-family: Courier New, Courier, monospace;">state.gpr[5] = gpr5;</span><br /><br />Javascript engines could do this directly, but since gpr is a view of a ArrayBuffer, that could be accessed as another view, it is a hard optimization and probably most engines won't do it. But local variable could lead to faster register allocation.<br />You can check it here that using a plain local variable is the fastest in every browser:&nbsp;<a href="http://jsperf.com/loop-with-array-as-variables/4">http://jsperf.com/loop-with-array-as-variables/4</a><br /><br />The idea is to determine registers used in a loop and copy the value into local variables, and use those local variables instead in the ast. After the loop or before a return or a call, we should restore those registers in local variables into the gpr array.<br /><h2>Bigger functions</h2>Bigger function mean to have branches, and function calls from the guest inside the recompiled function.<br /><br />Javascript doesn't have "goto". So the solution is harder than generating code into a virtual machine (java, C#) or a target host (directly generating x86, x64 or arm) that have goto instructions.<br /><br /><b>Bigger functions (phase 1)</b><br /><br />A first simple way to get it working is to create a state machine:<br /><br /><span style="font-family: Courier New, Courier, monospace;">var stateIndex = 0;</span><br /><span style="font-family: Courier New, Courier, monospace;">stateLoop: while (true) {</span><br /><span style="font-family: Courier New, Courier, monospace;">&nbsp; &nbsp; switch (stateIndex) {</span><br /><span style="font-family: Courier New, Courier, monospace;">&nbsp; &nbsp; &nbsp; &nbsp; case 0:</span><br /><span style="font-family: Courier New, Courier, monospace;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state.gpr[5] = 0;</span><br /><span style="font-family: Courier New, Courier, monospace;">&nbsp; &nbsp; &nbsp; &nbsp; case 1:</span><br /><span style="font-family: Courier New, Courier, monospace;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state.gpr[5] = state.lh(((state.gpr[4] + 0) | 0));</span><br /><span style="font-family: Courier New, Courier, monospace;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state.gpr[5] = state.gpr[5] + 1;</span><br /><span style="font-family: Courier New, Courier, monospace;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (state.gpr[5] &lt; 10) {</span><br /><span style="font-family: Courier New, Courier, monospace;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stateIndex = 1;</span><br /><span style="font-family: Courier New, Courier, monospace;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; continue stateLoop;</span><br /><span style="font-family: Courier New, Courier, monospace;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span><br /><span style="font-family: Courier New, Courier, monospace;">&nbsp; &nbsp; &nbsp; &nbsp; case 2:</span><br /><span style="font-family: Courier New, Courier, monospace;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break stateLoop;</span><br /><span style="font-family: Courier New, Courier, monospace;">&nbsp; &nbsp; }</span><br /><span style="font-family: Courier New, Courier, monospace;">}</span><br /><span style="font-family: Courier New, Courier, monospace;">return;</span><br /><div><br /></div><div>We have a single loop and a switch inside. Each "label" where a branch happens is a case, a jump/branch either ahead or behind is a value change into the switch subject and a continue refering to the while.</div><div>That way we can simulate whiles, ifs, and arbitrary jumps that won't fit any of this.</div><div><br /></div><div><b>Bigger functions (phase 2)</b></div><div><br /></div><div>After this, we can improve the state machine into something better. We can detect jumps that define a segment between the jump and the label it jumps to that have a simple property: al inside labels and jumps inside that segment, all are inside that segment. So we can convert that into a while or an if and process that segment in a divide and conquer fashion.</div><div>That way we can create loops and ifs where it is possible and use machine states when it is not.</div><h2>Calls inside functions</h2><div>Would be great to have function calling other functions instead of returning to a main loop to perform that function call.</div><div><br /></div><div><b>Check the address after the return</b></div><div><b><br /></b></div><div>In order to make a call we have to take into account that the function we have called could have been changed. Also we should know that MIPS "jal(r)" (Jump Anf Link (Register)) is not like a x86 "call" instruction. It just updates a register with the return address. But assembly methods can use it not as a normal call. And the function we call to, could have returned to other place. So after that call we have to check that the PC is indeed the PC after that function call. And if that is not the case, we should return to the execution main loop to determine the next function to execute. Either by returning recursively using a return convention or with an exception.</div><div><br /></div><div><b>Function changed/Instruction cache</b></div><div><br /></div><div>In some cases programs create code or update some code and they are invalidating the instruction cache. In that case it is possible to have a function referencing another function that have been changed. If you have inlined it, you have to invalidate update all the functions that referenced it. Also what if you have a function cached in a local variable? Since javascript do very good inlining and also have optimistic optimizations. We can just return functions that call another functions that we can change later on and let javascript engines to do all the work.</div><h2>Jumps</h2><div>Jumps are an interesting feature. Some jumps are local to the function we have created, so we can just treat them as an inconditional branch. Some other jumps are outside our function. But, calling a function would grow the calling stack, and that's bad, but our code is in another function.</div><div><br /></div><div>So in the end a jump is like a call, but removes the current stack frame, or doesn't create a new one. Indeed it is like a tail call. ES6 ensures tail call optimizations. So in the future it would be as easy as calling the function we want, and just after then returning the function without doing anymore. So the stack won't need anymore, and it will replace the stackframe.</div><div><br /></div><div>But, hey, we are in the present and we are targeting ES5 engines. How we will be able to handle that? With a return convention. So have to remove the current stackframe. How? Returning the function. But ensuring that the caller will call the function we are jumping into. So our returning convention should be able to return a function to jump in. And after every single call we should check if we are in a jump, and calling it immediately after the call that requested the jump.</div><div><br /></div><div>---</div><div><br /></div><div>With bigger functions, local variable allocations, calling and jumps, the performance will improve hugely and with javascript engines improving without a stop we will be able to get games running in a browser in a mobile phone sooner than later.</div><br /><br />